import { basicIntegrations, defaultScmResolveUrl } from '../helpers.esm.js';
import { readGithubIntegrationConfigs } from './config.esm.js';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, key + "" , value);
  return value;
};
const _GithubIntegration = class _GithubIntegration {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  get type() {
    return "github";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    return replaceGithubUrlType(defaultScmResolveUrl(options), "tree");
  }
  resolveEditUrl(url) {
    return replaceGithubUrlType(url, "edit");
  }
  parseRateLimitInfo(response) {
    return {
      isRateLimited: response.status === 429 || response.status === 403 && response.headers.get("x-ratelimit-remaining") === "0"
    };
  }
};
__publicField(_GithubIntegration, "factory", ({ config }) => {
  var _a;
  const configs = readGithubIntegrationConfigs(
    (_a = config.getOptionalConfigArray("integrations.github")) != null ? _a : []
  );
  return basicIntegrations(
    configs.map((c) => new _GithubIntegration(c)),
    (i) => i.config.host
  );
});
let GithubIntegration = _GithubIntegration;
function replaceGithubUrlType(url, type) {
  return url.replace(
    /\/\/([^/]+)\/([^/]+)\/([^/]+)\/(blob|tree|edit)\//,
    (_, host, owner, repo) => {
      return `//${host}/${owner}/${repo}/${type}/`;
    }
  );
}

export { GithubIntegration, replaceGithubUrlType };
//# sourceMappingURL=GithubIntegration.esm.js.map
