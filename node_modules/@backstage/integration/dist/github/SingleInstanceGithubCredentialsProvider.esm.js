import parseGitUrl from 'git-url-parse';
import { createAppAuth } from '@octokit/auth-app';
import { Octokit } from '@octokit/rest';
import { DateTime } from 'luxon';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Cache {
  constructor() {
    __publicField(this, "tokenCache", /* @__PURE__ */ new Map());
    __publicField(this, "isExpired", (date) => DateTime.local() > date);
  }
  async getOrCreateToken(owner, repo, supplier) {
    let existingInstallationData = this.tokenCache.get(owner);
    if (!existingInstallationData || this.isExpired(existingInstallationData.expiresAt)) {
      existingInstallationData = await supplier();
      existingInstallationData.expiresAt = existingInstallationData.expiresAt.minus({ minutes: 10 });
      this.tokenCache.set(owner, existingInstallationData);
    }
    if (!this.appliesToRepo(existingInstallationData, repo)) {
      throw new Error(
        `The Backstage GitHub application used in the ${owner} organization does not have access to a repository with the name ${repo}`
      );
    }
    return { accessToken: existingInstallationData.token };
  }
  appliesToRepo(tokenData, repo) {
    if (repo === void 0) {
      return true;
    }
    if (tokenData.repositories !== void 0) {
      return tokenData.repositories.includes(repo);
    }
    return true;
  }
}
const HEADERS = {
  Accept: "application/vnd.github.machine-man-preview+json"
};
class GithubAppManager {
  // undefined allows all installations
  constructor(config, baseUrl) {
    __publicField(this, "appClient");
    __publicField(this, "baseUrl");
    __publicField(this, "baseAuthConfig");
    __publicField(this, "cache", new Cache());
    __publicField(this, "allowedInstallationOwners");
    this.allowedInstallationOwners = config.allowedInstallationOwners;
    this.baseUrl = baseUrl;
    this.baseAuthConfig = {
      appId: config.appId,
      privateKey: config.privateKey.replace(/\\n/gm, "\n")
    };
    this.appClient = new Octokit({
      baseUrl,
      headers: HEADERS,
      authStrategy: createAppAuth,
      auth: this.baseAuthConfig
    });
  }
  async getInstallationCredentials(owner, repo) {
    var _a;
    if (this.allowedInstallationOwners) {
      if (!((_a = this.allowedInstallationOwners) == null ? void 0 : _a.includes(owner))) {
        return { accessToken: void 0 };
      }
    }
    return this.cache.getOrCreateToken(owner, repo, async () => {
      var _a2;
      const { installationId, suspended } = await this.getInstallationData(
        owner
      );
      if (suspended) {
        throw new Error(`The GitHub application for ${owner} is suspended`);
      }
      const result = await this.appClient.apps.createInstallationAccessToken({
        installation_id: installationId,
        headers: HEADERS
      });
      let repositoryNames;
      if (result.data.repository_selection === "selected") {
        const installationClient = new Octokit({
          baseUrl: this.baseUrl,
          auth: result.data.token
        });
        const repos = await installationClient.paginate(
          installationClient.apps.listReposAccessibleToInstallation
        );
        const repositories = (_a2 = repos.repositories) != null ? _a2 : repos;
        repositoryNames = repositories.map((repository) => repository.name);
      }
      return {
        token: result.data.token,
        expiresAt: DateTime.fromISO(result.data.expires_at),
        repositories: repositoryNames
      };
    });
  }
  getInstallations() {
    return this.appClient.paginate(this.appClient.apps.listInstallations);
  }
  async getInstallationData(owner) {
    const allInstallations = await this.getInstallations();
    const installation = allInstallations.find(
      (inst) => {
        var _a;
        return inst.account && "login" in inst.account && ((_a = inst.account.login) == null ? void 0 : _a.toLocaleLowerCase("en-US")) === owner.toLocaleLowerCase("en-US");
      }
    );
    if (installation) {
      return {
        installationId: installation.id,
        suspended: Boolean(installation.suspended_by)
      };
    }
    const notFoundError = new Error(
      `No app installation found for ${owner} in ${this.baseAuthConfig.appId}`
    );
    notFoundError.name = "NotFoundError";
    throw notFoundError;
  }
}
class GithubAppCredentialsMux {
  constructor(config) {
    __publicField(this, "apps");
    var _a, _b;
    this.apps = (_b = (_a = config.apps) == null ? void 0 : _a.map((ac) => new GithubAppManager(ac, config.apiBaseUrl))) != null ? _b : [];
  }
  async getAllInstallations() {
    if (!this.apps.length) {
      return [];
    }
    const installs = await Promise.all(
      this.apps.map((app) => app.getInstallations())
    );
    return installs.flat();
  }
  async getAppToken(owner, repo) {
    if (this.apps.length === 0) {
      return void 0;
    }
    const results = await Promise.all(
      this.apps.map(
        (app) => app.getInstallationCredentials(owner, repo).then(
          (credentials) => ({ credentials, error: void 0 }),
          (error) => ({ credentials: void 0, error })
        )
      )
    );
    const result = results.find(
      (resultItem) => {
        var _a;
        return (_a = resultItem.credentials) == null ? void 0 : _a.accessToken;
      }
    );
    if (result) {
      return result.credentials.accessToken;
    }
    const errors = results.map((r) => r.error);
    const notNotFoundError = errors.find((err) => (err == null ? void 0 : err.name) !== "NotFoundError");
    if (notNotFoundError) {
      throw notNotFoundError;
    }
    return void 0;
  }
}
const _SingleInstanceGithubCredentialsProvider = class _SingleInstanceGithubCredentialsProvider {
  constructor(githubAppCredentialsMux, token) {
    this.githubAppCredentialsMux = githubAppCredentialsMux;
    this.token = token;
  }
  /**
   * Returns {@link GithubCredentials} for a given URL.
   *
   * @remarks
   *
   * Consecutive calls to this method with the same URL will return cached
   * credentials.
   *
   * The shortest lifetime for a token returned is 10 minutes.
   *
   * @example
   * ```ts
   * const { token, headers } = await getCredentials({
   *   url: 'github.com/backstage/foobar'
   * })
   * ```
   *
   * @param opts - The organization or repository URL
   * @returns A promise of {@link GithubCredentials}.
   */
  async getCredentials(opts) {
    const parsed = parseGitUrl(opts.url);
    const owner = parsed.owner || parsed.name;
    const repo = parsed.owner ? parsed.name : void 0;
    let type = "app";
    let token = await this.githubAppCredentialsMux.getAppToken(owner, repo);
    if (!token) {
      type = "token";
      token = this.token;
    }
    return {
      headers: token ? { Authorization: `Bearer ${token}` } : void 0,
      token,
      type
    };
  }
};
__publicField(_SingleInstanceGithubCredentialsProvider, "create", (config) => {
  return new _SingleInstanceGithubCredentialsProvider(
    new GithubAppCredentialsMux(config),
    config.token
  );
});
let SingleInstanceGithubCredentialsProvider = _SingleInstanceGithubCredentialsProvider;

export { GithubAppCredentialsMux, SingleInstanceGithubCredentialsProvider };
//# sourceMappingURL=SingleInstanceGithubCredentialsProvider.esm.js.map
