var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var _origin, _owner, _project, _repo, _path, _ref, _baseUrl;
const VERSION_PREFIX_GIT_BRANCH = "GB";
const _AzureUrl = class _AzureUrl {
  constructor(origin, owner, project, repo, path, ref) {
    __privateAdd(this, _origin, void 0);
    __privateAdd(this, _owner, void 0);
    __privateAdd(this, _project, void 0);
    __privateAdd(this, _repo, void 0);
    __privateAdd(this, _path, void 0);
    __privateAdd(this, _ref, void 0);
    __privateAdd(this, _baseUrl, (...parts) => {
      const url = new URL(__privateGet(this, _origin));
      url.pathname = parts.map((part) => encodeURIComponent(part)).join("/");
      return url;
    });
    __privateSet(this, _origin, origin);
    __privateSet(this, _owner, owner);
    __privateSet(this, _project, project);
    __privateSet(this, _repo, repo);
    __privateSet(this, _path, path);
    __privateSet(this, _ref, ref);
  }
  /**
   * Parses an azure URL as copied from the browser address bar.
   *
   * Throws an error if the URL is not a valid azure repo URL.
   */
  static fromRepoUrl(repoUrl) {
    var _a;
    const url = new URL(repoUrl);
    let owner;
    let project;
    let repo;
    const parts = url.pathname.split("/").map((part) => decodeURIComponent(part));
    if (parts[2] === "_git") {
      owner = parts[1];
      project = repo = parts[3];
    } else if (parts[3] === "_git") {
      owner = parts[1];
      project = parts[2];
      repo = parts[4];
    } else if (parts[4] === "_git") {
      owner = `${parts[1]}/${parts[2]}`;
      project = parts[3];
      repo = parts[5];
    }
    if (!owner || !project || !repo) {
      throw new Error("Azure URL must point to a git repository");
    }
    const path = (_a = url.searchParams.get("path")) != null ? _a : void 0;
    let ref;
    const version = url.searchParams.get("version");
    if (version) {
      const prefix = version.slice(0, 2);
      if (prefix !== "GB") {
        throw new Error("Azure URL version must point to a git branch");
      }
      ref = version.slice(2);
    }
    return new _AzureUrl(url.origin, owner, project, repo, path, ref);
  }
  /**
   * Returns a repo URL that can be used to navigate to the resource in azure.
   *
   * Throws an error if the URL is not a valid azure repo URL.
   */
  toRepoUrl() {
    let url;
    if (__privateGet(this, _project) === __privateGet(this, _repo)) {
      url = __privateGet(this, _baseUrl).call(this, __privateGet(this, _owner), "_git", __privateGet(this, _repo));
    } else {
      url = __privateGet(this, _baseUrl).call(this, __privateGet(this, _owner), __privateGet(this, _project), "_git", __privateGet(this, _repo));
    }
    if (__privateGet(this, _path)) {
      url.searchParams.set("path", __privateGet(this, _path));
    }
    if (__privateGet(this, _ref)) {
      url.searchParams.set("version", VERSION_PREFIX_GIT_BRANCH + __privateGet(this, _ref));
    }
    return url.toString();
  }
  /**
   * Returns the file download URL for this azure resource.
   *
   * Throws an error if the URL does not point to a file.
   */
  toFileUrl() {
    if (!__privateGet(this, _path)) {
      throw new Error(
        "Azure URL must point to a specific path to be able to download a file"
      );
    }
    const url = __privateGet(this, _baseUrl).call(this, __privateGet(this, _owner), __privateGet(this, _project), "_apis", "git", "repositories", __privateGet(this, _repo), "items");
    url.searchParams.set("api-version", "6.0");
    url.searchParams.set("path", __privateGet(this, _path));
    if (__privateGet(this, _ref)) {
      url.searchParams.set("version", __privateGet(this, _ref));
    }
    return url.toString();
  }
  /**
   * Returns the archive download URL for this azure resource.
   *
   * Throws an error if the URL does not point to a repo.
   */
  toArchiveUrl() {
    const url = __privateGet(this, _baseUrl).call(this, __privateGet(this, _owner), __privateGet(this, _project), "_apis", "git", "repositories", __privateGet(this, _repo), "items");
    url.searchParams.set("recursionLevel", "full");
    url.searchParams.set("download", "true");
    url.searchParams.set("api-version", "6.0");
    if (__privateGet(this, _path)) {
      url.searchParams.set("scopePath", __privateGet(this, _path));
    }
    if (__privateGet(this, _ref)) {
      url.searchParams.set("version", __privateGet(this, _ref));
    }
    return url.toString();
  }
  /**
   * Returns the API url for fetching commits from a branch for this azure resource.
   *
   * Throws an error if the URL does not point to a commit.
   */
  toCommitsUrl() {
    const url = __privateGet(this, _baseUrl).call(this, __privateGet(this, _owner), __privateGet(this, _project), "_apis", "git", "repositories", __privateGet(this, _repo), "commits");
    url.searchParams.set("api-version", "6.0");
    if (__privateGet(this, _ref)) {
      url.searchParams.set("searchCriteria.itemVersion.version", __privateGet(this, _ref));
    }
    return url.toString();
  }
  /**
   * Returns the name of the owner, a user or an organization.
   */
  getOwner() {
    return __privateGet(this, _owner);
  }
  /**
   * Returns the name of the project.
   */
  getProject() {
    return __privateGet(this, _project);
  }
  /**
   * Returns the name of the repo.
   */
  getRepo() {
    return __privateGet(this, _repo);
  }
  /**
   * Returns the file path within the repo if the URL contains one.
   */
  getPath() {
    return __privateGet(this, _path);
  }
  /**
   * Returns the git ref in the repo if the URL contains one.
   */
  getRef() {
    return __privateGet(this, _ref);
  }
};
_origin = new WeakMap();
_owner = new WeakMap();
_project = new WeakMap();
_repo = new WeakMap();
_path = new WeakMap();
_ref = new WeakMap();
_baseUrl = new WeakMap();
let AzureUrl = _AzureUrl;

export { AzureUrl };
//# sourceMappingURL=AzureUrl.esm.js.map
