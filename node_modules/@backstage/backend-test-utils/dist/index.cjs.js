'use strict';

var backendCommon = require('@backstage/backend-common');
var config = require('@backstage/config');
var crypto = require('crypto');
var createConnection = require('knex');
var uuid = require('uuid');
var os = require('os');
var backendPluginApi = require('@backstage/backend-plugin-api');
var fs = require('fs-extra');
var textextensions = require('textextensions');
var path = require('path');
var backendAppApi = require('@backstage/backend-app-api');
var errors = require('@backstage/errors');
var cookie = require('cookie');
var pluginEventsNode = require('@backstage/plugin-events-node');
var express = require('express');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var createConnection__default = /*#__PURE__*/_interopDefaultCompat(createConnection);
var os__default = /*#__PURE__*/_interopDefaultCompat(os);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var textextensions__default = /*#__PURE__*/_interopDefaultCompat(textextensions);
var express__default = /*#__PURE__*/_interopDefaultCompat(express);

function isDockerDisabledForTests() {
  return Boolean(process.env.BACKSTAGE_TEST_DISABLE_DOCKER) || !Boolean(process.env.CI);
}

async function waitForMysqlReady(connection) {
  var _a;
  const startTime = Date.now();
  const db = createConnection__default.default({ client: "mysql2", connection });
  try {
    for (; ; ) {
      try {
        const result = await db.select(db.raw("version() AS version"));
        if ((_a = result[0]) == null ? void 0 : _a.version) {
          return;
        }
      } catch (e) {
        if (Date.now() - startTime > 3e4) {
          throw new Error(
            `Timed out waiting for the database to be ready for connections, ${e}`
          );
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  } finally {
    db.destroy();
  }
}
async function startMysqlContainer(image) {
  const user = "root";
  const password = uuid.v4();
  const { GenericContainer } = await import('testcontainers');
  const container = await new GenericContainer(image).withExposedPorts(3306).withEnvironment({ MYSQL_ROOT_PASSWORD: password }).withTmpFs({ "/var/lib/mysql": "rw" }).start();
  const host = container.getHost();
  const port = container.getMappedPort(3306);
  const stop = async () => {
    await container.stop({ timeout: 1e4 });
  };
  await waitForMysqlReady({ host, port, user, password });
  return { host, port, user, password, stop };
}

async function waitForPostgresReady(connection) {
  var _a;
  const startTime = Date.now();
  const db = createConnection__default.default({ client: "pg", connection });
  try {
    for (; ; ) {
      try {
        const result = await db.select(db.raw("version()"));
        if (Array.isArray(result) && ((_a = result[0]) == null ? void 0 : _a.version)) {
          return;
        }
      } catch (e) {
        if (Date.now() - startTime > 3e4) {
          throw new Error(
            `Timed out waiting for the database to be ready for connections, ${e}`
          );
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  } finally {
    db.destroy();
  }
}
async function startPostgresContainer(image) {
  const user = "postgres";
  const password = uuid.v4();
  const { GenericContainer } = await import('testcontainers');
  const container = await new GenericContainer(image).withExposedPorts(5432).withEnvironment({ POSTGRES_PASSWORD: password }).withTmpFs({ "/var/lib/postgresql/data": "rw" }).start();
  const host = container.getHost();
  const port = container.getMappedPort(5432);
  const stop = async () => {
    await container.stop({ timeout: 1e4 });
  };
  await waitForPostgresReady({ host, port, user, password });
  return { host, port, user, password, stop };
}

const getDockerImageForName = (name) => {
  return process.env.BACKSTAGE_TEST_DOCKER_REGISTRY ? `${process.env.BACKSTAGE_TEST_DOCKER_REGISTRY}/${name}` : name;
};

const allDatabases = Object.freeze({
  POSTGRES_16: {
    name: "Postgres 16.x",
    driver: "pg",
    dockerImageName: getDockerImageForName("postgres:16"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_POSTGRES16_CONNECTION_STRING"
  },
  POSTGRES_15: {
    name: "Postgres 15.x",
    driver: "pg",
    dockerImageName: getDockerImageForName("postgres:15"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_POSTGRES15_CONNECTION_STRING"
  },
  POSTGRES_14: {
    name: "Postgres 14.x",
    driver: "pg",
    dockerImageName: getDockerImageForName("postgres:14"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_POSTGRES14_CONNECTION_STRING"
  },
  POSTGRES_13: {
    name: "Postgres 13.x",
    driver: "pg",
    dockerImageName: getDockerImageForName("postgres:13"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_POSTGRES13_CONNECTION_STRING"
  },
  POSTGRES_12: {
    name: "Postgres 12.x",
    driver: "pg",
    dockerImageName: getDockerImageForName("postgres:12"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_POSTGRES12_CONNECTION_STRING"
  },
  POSTGRES_11: {
    name: "Postgres 11.x",
    driver: "pg",
    dockerImageName: getDockerImageForName("postgres:11"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_POSTGRES11_CONNECTION_STRING"
  },
  POSTGRES_9: {
    name: "Postgres 9.x",
    driver: "pg",
    dockerImageName: getDockerImageForName("postgres:9"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_POSTGRES9_CONNECTION_STRING"
  },
  MYSQL_8: {
    name: "MySQL 8.x",
    driver: "mysql2",
    dockerImageName: getDockerImageForName("mysql:8"),
    connectionStringEnvironmentVariableName: "BACKSTAGE_TEST_DATABASE_MYSQL8_CONNECTION_STRING"
  },
  SQLITE_3: {
    name: "SQLite 3.x",
    driver: "better-sqlite3"
  }
});

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const LARGER_POOL_CONFIG = {
  pool: {
    min: 0,
    max: 50
  }
};
const _TestDatabases = class _TestDatabases {
  constructor(supportedIds) {
    __publicField$3(this, "instanceById");
    __publicField$3(this, "supportedIds");
    this.instanceById = /* @__PURE__ */ new Map();
    this.supportedIds = supportedIds;
  }
  /**
   * Creates an empty `TestDatabases` instance, and sets up Jest to clean up
   * all of its acquired resources after all tests finish.
   *
   * You typically want to create just a single instance like this at the top
   * of your test file or `describe` block, and then call `init` many times on
   * that instance inside the individual tests. Spinning up a "physical"
   * database instance takes a considerable amount of time, slowing down tests.
   * But initializing a new logical database inside that instance using `init`
   * is very fast.
   */
  static create(options) {
    var _a;
    const ids = options == null ? void 0 : options.ids;
    const disableDocker = (_a = options == null ? void 0 : options.disableDocker) != null ? _a : isDockerDisabledForTests();
    let testDatabaseIds;
    if (ids) {
      testDatabaseIds = ids;
    } else if (_TestDatabases.defaultIds) {
      testDatabaseIds = _TestDatabases.defaultIds;
    } else {
      testDatabaseIds = Object.keys(allDatabases);
    }
    const supportedIds = testDatabaseIds.filter((id) => {
      const properties = allDatabases[id];
      if (!properties) {
        return false;
      }
      if (properties.connectionStringEnvironmentVariableName && process.env[properties.connectionStringEnvironmentVariableName]) {
        return true;
      }
      if (!properties.dockerImageName) {
        return true;
      }
      if (disableDocker) {
        return false;
      }
      return true;
    });
    const databases = new _TestDatabases(supportedIds);
    if (supportedIds.length > 0) {
      afterAll(async () => {
        await databases.shutdown();
      });
    }
    return databases;
  }
  static setDefaults(options) {
    _TestDatabases.defaultIds = options.ids;
  }
  supports(id) {
    return this.supportedIds.includes(id);
  }
  eachSupportedId() {
    return this.supportedIds.map((id) => [id]);
  }
  /**
   * Returns a fresh, unique, empty logical database on an instance of the
   * given database ID platform.
   *
   * @param id - The ID of the database platform to use, e.g. 'POSTGRES_13'
   * @returns A `Knex` connection object
   */
  async init(id) {
    const properties = allDatabases[id];
    if (!properties) {
      const candidates = Object.keys(allDatabases).join(", ");
      throw new Error(
        `Unknown test database ${id}, possible values are ${candidates}`
      );
    }
    if (!this.supportedIds.includes(id)) {
      const candidates = this.supportedIds.join(", ");
      throw new Error(
        `Unsupported test database ${id} for this environment, possible values are ${candidates}`
      );
    }
    let instance = this.instanceById.get(id);
    if (!instance) {
      instance = await this.initAny(properties);
      this.instanceById.set(id, instance);
    }
    const databaseName = `db${crypto.randomBytes(16).toString("hex")}`;
    const connection = await instance.databaseManager.forPlugin(databaseName).getClient();
    instance.connections.push(connection);
    instance.databaseNames.push(databaseName);
    return connection;
  }
  async initAny(properties) {
    if (properties.driver === "pg" || properties.driver === "mysql2") {
      const envVarName = properties.connectionStringEnvironmentVariableName;
      if (envVarName) {
        const connectionString = process.env[envVarName];
        if (connectionString) {
          const config$1 = new config.ConfigReader({
            backend: {
              database: {
                knexConfig: properties.driver.includes("sqlite") ? {} : LARGER_POOL_CONFIG,
                client: properties.driver,
                connection: connectionString
              }
            }
          });
          const databaseManager = backendCommon.DatabaseManager.fromConfig(config$1);
          const databaseNames = [];
          return {
            dropDatabases: async () => {
              await backendCommon.dropDatabase(
                config$1.getConfig("backend.database"),
                ...databaseNames.map(
                  (databaseName) => `backstage_plugin_${databaseName}`
                )
              );
            },
            databaseManager,
            databaseNames,
            connections: []
          };
        }
      }
    }
    switch (properties.driver) {
      case "pg":
        return this.initPostgres(properties);
      case "mysql2":
        return this.initMysql(properties);
      case "better-sqlite3":
      case "sqlite3":
        return this.initSqlite(properties);
      default:
        throw new Error(`Unknown database driver ${properties.driver}`);
    }
  }
  async initPostgres(properties) {
    const { host, port, user, password, stop } = await startPostgresContainer(
      properties.dockerImageName
    );
    const databaseManager = backendCommon.DatabaseManager.fromConfig(
      new config.ConfigReader({
        backend: {
          database: {
            knexConfig: LARGER_POOL_CONFIG,
            client: "pg",
            connection: { host, port, user, password }
          }
        }
      })
    );
    return {
      stopContainer: stop,
      databaseManager,
      databaseNames: [],
      connections: []
    };
  }
  async initMysql(properties) {
    const { host, port, user, password, stop } = await startMysqlContainer(
      properties.dockerImageName
    );
    const databaseManager = backendCommon.DatabaseManager.fromConfig(
      new config.ConfigReader({
        backend: {
          database: {
            knexConfig: LARGER_POOL_CONFIG,
            client: "mysql2",
            connection: { host, port, user, password }
          }
        }
      })
    );
    return {
      stopContainer: stop,
      databaseManager,
      databaseNames: [],
      connections: []
    };
  }
  async initSqlite(properties) {
    const databaseManager = backendCommon.DatabaseManager.fromConfig(
      new config.ConfigReader({
        backend: {
          database: {
            client: properties.driver,
            connection: ":memory:"
          }
        }
      })
    );
    return {
      databaseManager,
      databaseNames: [],
      connections: []
    };
  }
  async shutdown() {
    const instances = [...this.instanceById.values()];
    this.instanceById.clear();
    for (const {
      stopContainer,
      dropDatabases,
      connections,
      databaseManager
    } of instances) {
      for (const connection of connections) {
        try {
          await connection.destroy();
        } catch (error) {
          console.warn(`TestDatabases: Failed to destroy connection`, {
            connection,
            error
          });
        }
      }
      try {
        await (dropDatabases == null ? void 0 : dropDatabases());
      } catch (error) {
        console.warn(`TestDatabases: Failed to drop databases`, {
          error
        });
      }
      try {
        await (stopContainer == null ? void 0 : stopContainer());
      } catch (error) {
        console.warn(`TestDatabases: Failed to stop container`, {
          databaseManager,
          error
        });
      }
    }
  }
};
__publicField$3(_TestDatabases, "defaultIds");
let TestDatabases = _TestDatabases;

function setupRequestMockHandlers(worker) {
  beforeAll(() => worker.listen({ onUnhandledRequest: "error" }));
  afterAll(() => worker.close());
  afterEach(() => worker.resetHandlers());
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck$5 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$5 = (obj, member, getter) => {
  __accessCheck$5(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd$5 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$5 = (obj, member, value, setter) => {
  __accessCheck$5(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var __privateMethod$4 = (obj, member, method) => {
  __accessCheck$5(obj, member, "access private method");
  return method;
};
var _root, _transformInput, transformInput_fn;
const tmpdirMarker = Symbol("os-tmpdir-mock");
class MockDirectoryImpl {
  constructor(root) {
    __privateAdd$5(this, _transformInput);
    __privateAdd$5(this, _root, void 0);
    __publicField$2(this, "clear", () => {
      this.setContent({});
    });
    __publicField$2(this, "remove", () => {
      fs__default.default.rmSync(__privateGet$5(this, _root), { recursive: true, force: true, maxRetries: 10 });
    });
    __privateSet$5(this, _root, root);
  }
  get path() {
    return __privateGet$5(this, _root);
  }
  resolve(...paths) {
    return path.resolve(__privateGet$5(this, _root), ...paths);
  }
  setContent(root) {
    this.remove();
    return this.addContent(root);
  }
  addContent(root) {
    const entries = __privateMethod$4(this, _transformInput, transformInput_fn).call(this, root);
    for (const entry of entries) {
      const fullPath = path.resolve(__privateGet$5(this, _root), entry.path);
      if (!backendPluginApi.isChildPath(__privateGet$5(this, _root), fullPath)) {
        throw new Error(
          `Provided path must resolve to a child path of the mock directory, got '${fullPath}'`
        );
      }
      if (entry.type === "dir") {
        fs__default.default.ensureDirSync(fullPath);
      } else if (entry.type === "file") {
        fs__default.default.ensureDirSync(path.dirname(fullPath));
        fs__default.default.writeFileSync(fullPath, entry.content);
      } else if (entry.type === "callback") {
        fs__default.default.ensureDirSync(path.dirname(fullPath));
        entry.callback({
          path: fullPath,
          symlink(target) {
            fs__default.default.symlinkSync(target, fullPath);
          }
        });
      }
    }
  }
  content(options) {
    var _a, _b;
    const shouldReadAsText = (_a = typeof (options == null ? void 0 : options.shouldReadAsText) === "boolean" ? () => options == null ? void 0 : options.shouldReadAsText : options == null ? void 0 : options.shouldReadAsText) != null ? _a : (path$1) => textextensions__default.default.includes(path.extname(path$1).slice(1));
    const root = path.resolve(__privateGet$5(this, _root), (_b = options == null ? void 0 : options.path) != null ? _b : "");
    if (!backendPluginApi.isChildPath(__privateGet$5(this, _root), root)) {
      throw new Error(
        `Provided path must resolve to a child path of the mock directory, got '${root}'`
      );
    }
    function read(path$1) {
      if (!fs__default.default.pathExistsSync(path$1)) {
        return void 0;
      }
      const entries = fs__default.default.readdirSync(path$1, { withFileTypes: true });
      return Object.fromEntries(
        entries.map((entry) => {
          const fullPath = path.resolve(path$1, entry.name);
          if (entry.isDirectory()) {
            return [entry.name, read(fullPath)];
          }
          const content = fs__default.default.readFileSync(fullPath);
          const relativePosixPath = path.relative(root, fullPath).split(path.win32.sep).join(path.posix.sep);
          if (shouldReadAsText(relativePosixPath, content)) {
            return [entry.name, content.toString("utf8")];
          }
          return [entry.name, content];
        })
      );
    }
    return read(root);
  }
}
_root = new WeakMap();
_transformInput = new WeakSet();
transformInput_fn = function(input) {
  const entries = [];
  function traverse(node, path) {
    if (typeof node === "string") {
      entries.push({
        type: "file",
        path,
        content: Buffer.from(node, "utf8")
      });
    } else if (node instanceof Buffer) {
      entries.push({ type: "file", path, content: node });
    } else if (typeof node === "function") {
      entries.push({ type: "callback", path, callback: node });
    } else {
      entries.push({ type: "dir", path });
      for (const [name, child] of Object.entries(node)) {
        traverse(child, path ? `${path}/${name}` : name);
      }
    }
  }
  traverse(input, "");
  return entries;
};
function createMockDirectory(options) {
  const tmpDir = process.env.RUNNER_TEMP || os__default.default.tmpdir();
  const root = fs__default.default.mkdtempSync(path.join(tmpDir, "backstage-tmp-test-dir-"));
  const mocker = new MockDirectoryImpl(root);
  const origTmpdir = (options == null ? void 0 : options.mockOsTmpDir) ? os__default.default.tmpdir : void 0;
  if (origTmpdir) {
    if (Object.hasOwn(origTmpdir, tmpdirMarker)) {
      throw new Error(
        "Cannot mock os.tmpdir() when it has already been mocked"
      );
    }
    const mock = Object.assign(() => mocker.path, { [tmpdirMarker]: true });
    os__default.default.tmpdir = mock;
  }
  const needsCleanup = !process.env.CI;
  if (needsCleanup) {
    process.on("beforeExit", mocker.remove);
  }
  try {
    afterAll(() => {
      if (origTmpdir) {
        os__default.default.tmpdir = origTmpdir;
      }
      if (needsCleanup) {
        mocker.remove();
      }
    });
  } catch {
  }
  if (options == null ? void 0 : options.content) {
    mocker.setContent(options.content);
  }
  return mocker;
}

class MockIdentityService {
  getIdentity(_options) {
    return Promise.resolve({
      token: "mock-token",
      identity: {
        type: "user",
        userEntityRef: "user:default/mock-user",
        ownershipEntityRefs: []
      }
    });
  }
}

var __accessCheck$4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$4 = (obj, member, getter) => {
  __accessCheck$4(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd$4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$4 = (obj, member, value, setter) => {
  __accessCheck$4(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var __privateMethod$3 = (obj, member, method) => {
  __accessCheck$4(obj, member, "access private method");
  return method;
};
var _level, _meta, _log, log_fn;
const levels = {
  none: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
};
const _MockRootLoggerService = class _MockRootLoggerService {
  constructor(level, meta) {
    __privateAdd$4(this, _log);
    __privateAdd$4(this, _level, void 0);
    __privateAdd$4(this, _meta, void 0);
    __privateSet$4(this, _level, level);
    __privateSet$4(this, _meta, meta);
  }
  static create(options) {
    var _a;
    const level = (_a = options == null ? void 0 : options.level) != null ? _a : "none";
    if (!(level in levels)) {
      throw new Error(`Invalid log level '${level}'`);
    }
    return new _MockRootLoggerService(levels[level], {});
  }
  error(message, meta) {
    __privateMethod$3(this, _log, log_fn).call(this, "error", message, meta);
  }
  warn(message, meta) {
    __privateMethod$3(this, _log, log_fn).call(this, "warn", message, meta);
  }
  info(message, meta) {
    __privateMethod$3(this, _log, log_fn).call(this, "info", message, meta);
  }
  debug(message, meta) {
    __privateMethod$3(this, _log, log_fn).call(this, "debug", message, meta);
  }
  child(meta) {
    return new _MockRootLoggerService(__privateGet$4(this, _level), { ...__privateGet$4(this, _meta), ...meta });
  }
};
_level = new WeakMap();
_meta = new WeakMap();
_log = new WeakSet();
log_fn = function(level, message, meta) {
  var _a;
  const levelValue = (_a = levels[level]) != null ? _a : 0;
  if (levelValue <= __privateGet$4(this, _level)) {
    const labels = Object.entries(__privateGet$4(this, _meta)).map(([key, value]) => `${key}=${value}`).join(",");
    console[level](`${labels} ${message}`, meta);
  }
};
let MockRootLoggerService = _MockRootLoggerService;

const DEFAULT_MOCK_USER_ENTITY_REF = "user:default/mock";
const DEFAULT_MOCK_SERVICE_SUBJECT = "external:test-service";
const MOCK_AUTH_COOKIE = "backstage-auth";
const MOCK_NONE_TOKEN = "mock-none-token";
const MOCK_USER_TOKEN = "mock-user-token";
const MOCK_USER_TOKEN_PREFIX = "mock-user-token:";
const MOCK_INVALID_USER_TOKEN = "mock-invalid-user-token";
const MOCK_USER_LIMITED_TOKEN_PREFIX = "mock-limited-user-token:";
const MOCK_INVALID_USER_LIMITED_TOKEN = "mock-invalid-limited-user-token";
const MOCK_SERVICE_TOKEN = "mock-service-token";
const MOCK_SERVICE_TOKEN_PREFIX = "mock-service-token:";
const MOCK_INVALID_SERVICE_TOKEN = "mock-invalid-service-token";
function validateUserEntityRef(ref) {
  if (!ref.match(/^.+:.+\/.+$/)) {
    throw new TypeError(
      `Invalid user entity reference '${ref}', expected <kind>:<namespace>/<name>`
    );
  }
}
exports.mockCredentials = void 0;
((mockCredentials2) => {
  function none() {
    return {
      $$type: "@backstage/BackstageCredentials",
      principal: { type: "none" }
    };
  }
  mockCredentials2.none = none;
  ((none2) => {
    function header() {
      return `Bearer ${MOCK_NONE_TOKEN}`;
    }
    none2.header = header;
  })(none = mockCredentials2.none || (mockCredentials2.none = {}));
  function user(userEntityRef = DEFAULT_MOCK_USER_ENTITY_REF) {
    validateUserEntityRef(userEntityRef);
    return {
      $$type: "@backstage/BackstageCredentials",
      principal: { type: "user", userEntityRef }
    };
  }
  mockCredentials2.user = user;
  ((user2) => {
    function token(userEntityRef) {
      if (userEntityRef) {
        validateUserEntityRef(userEntityRef);
        return `${MOCK_USER_TOKEN_PREFIX}${JSON.stringify({
          sub: userEntityRef
        })}`;
      }
      return MOCK_USER_TOKEN;
    }
    user2.token = token;
    function header(userEntityRef) {
      return `Bearer ${token(userEntityRef)}`;
    }
    user2.header = header;
    function invalidToken() {
      return MOCK_INVALID_USER_TOKEN;
    }
    user2.invalidToken = invalidToken;
    function invalidHeader() {
      return `Bearer ${invalidToken()}`;
    }
    user2.invalidHeader = invalidHeader;
  })(user = mockCredentials2.user || (mockCredentials2.user = {}));
  function limitedUser(userEntityRef = DEFAULT_MOCK_USER_ENTITY_REF) {
    return user(userEntityRef);
  }
  mockCredentials2.limitedUser = limitedUser;
  ((limitedUser2) => {
    function token(userEntityRef = DEFAULT_MOCK_USER_ENTITY_REF) {
      validateUserEntityRef(userEntityRef);
      return `${MOCK_USER_LIMITED_TOKEN_PREFIX}${JSON.stringify({
        sub: userEntityRef
      })}`;
    }
    limitedUser2.token = token;
    function cookie(userEntityRef) {
      return `${MOCK_AUTH_COOKIE}=${token(userEntityRef)}`;
    }
    limitedUser2.cookie = cookie;
    function invalidToken() {
      return MOCK_INVALID_USER_LIMITED_TOKEN;
    }
    limitedUser2.invalidToken = invalidToken;
    function invalidCookie() {
      return `${MOCK_AUTH_COOKIE}=${invalidToken()}`;
    }
    limitedUser2.invalidCookie = invalidCookie;
  })(limitedUser = mockCredentials2.limitedUser || (mockCredentials2.limitedUser = {}));
  function service(subject = DEFAULT_MOCK_SERVICE_SUBJECT) {
    return {
      $$type: "@backstage/BackstageCredentials",
      principal: { type: "service", subject }
    };
  }
  mockCredentials2.service = service;
  ((service2) => {
    function token(options) {
      if (options) {
        const { targetPluginId, onBehalfOf } = options;
        const oboPrincipal = onBehalfOf == null ? void 0 : onBehalfOf.principal;
        const obo = oboPrincipal.type === "user" ? oboPrincipal.userEntityRef : void 0;
        const subject = oboPrincipal.type === "service" ? oboPrincipal.subject : void 0;
        return `${MOCK_SERVICE_TOKEN_PREFIX}${JSON.stringify({
          sub: subject,
          obo,
          target: targetPluginId
        })}`;
      }
      return MOCK_SERVICE_TOKEN;
    }
    service2.token = token;
    function header(options) {
      return `Bearer ${token(options)}`;
    }
    service2.header = header;
    function invalidToken() {
      return MOCK_INVALID_SERVICE_TOKEN;
    }
    service2.invalidToken = invalidToken;
    function invalidHeader() {
      return `Bearer ${invalidToken()}`;
    }
    service2.invalidHeader = invalidHeader;
  })(service = mockCredentials2.service || (mockCredentials2.service = {}));
})(exports.mockCredentials || (exports.mockCredentials = {}));

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MockAuthService {
  constructor(options) {
    __publicField$1(this, "pluginId");
    __publicField$1(this, "disableDefaultAuthPolicy");
    this.pluginId = options.pluginId;
    this.disableDefaultAuthPolicy = options.disableDefaultAuthPolicy;
  }
  async authenticate(token, options) {
    switch (token) {
      case MOCK_USER_TOKEN:
        return exports.mockCredentials.user();
      case MOCK_SERVICE_TOKEN:
        return exports.mockCredentials.service();
      case MOCK_INVALID_USER_TOKEN:
        throw new errors.AuthenticationError("User token is invalid");
      case MOCK_INVALID_USER_LIMITED_TOKEN:
        throw new errors.AuthenticationError("Limited user token is invalid");
      case MOCK_INVALID_SERVICE_TOKEN:
        throw new errors.AuthenticationError("Service token is invalid");
      case "":
        throw new errors.AuthenticationError("Token is empty");
    }
    if (token.startsWith(MOCK_USER_TOKEN_PREFIX)) {
      const { sub: userEntityRef } = JSON.parse(
        token.slice(MOCK_USER_TOKEN_PREFIX.length)
      );
      return exports.mockCredentials.user(userEntityRef);
    }
    if (token.startsWith(MOCK_USER_LIMITED_TOKEN_PREFIX)) {
      if (!(options == null ? void 0 : options.allowLimitedAccess)) {
        throw new errors.AuthenticationError("Limited user token is not allowed");
      }
      const { sub: userEntityRef } = JSON.parse(
        token.slice(MOCK_USER_LIMITED_TOKEN_PREFIX.length)
      );
      return exports.mockCredentials.user(userEntityRef);
    }
    if (token.startsWith(MOCK_SERVICE_TOKEN_PREFIX)) {
      const { sub, target, obo } = JSON.parse(
        token.slice(MOCK_SERVICE_TOKEN_PREFIX.length)
      );
      if (target && target !== this.pluginId) {
        throw new errors.AuthenticationError(
          `Invalid mock token target plugin ID, got '${target}' but expected '${this.pluginId}'`
        );
      }
      if (obo) {
        return exports.mockCredentials.user(obo);
      }
      return exports.mockCredentials.service(sub);
    }
    throw new errors.AuthenticationError(`Unknown mock token '${token}'`);
  }
  async getNoneCredentials() {
    return exports.mockCredentials.none();
  }
  async getOwnServiceCredentials() {
    return exports.mockCredentials.service(`plugin:${this.pluginId}`);
  }
  isPrincipal(credentials, type) {
    const principal = credentials.principal;
    if (type === "unknown") {
      return true;
    }
    if (principal.type !== type) {
      return false;
    }
    return true;
  }
  async getPluginRequestToken(options) {
    const principal = options.onBehalfOf.principal;
    if (principal.type === "none" && this.disableDefaultAuthPolicy) {
      return { token: "" };
    }
    if (principal.type !== "user" && principal.type !== "service") {
      throw new errors.AuthenticationError(
        `Refused to issue service token for credential type '${principal.type}'`
      );
    }
    return {
      token: exports.mockCredentials.service.token({
        onBehalfOf: options.onBehalfOf,
        targetPluginId: options.targetPluginId
      })
    };
  }
  async getLimitedUserToken(credentials) {
    if (credentials.principal.type !== "user") {
      throw new errors.AuthenticationError(
        `Refused to issue limited user token for credential type '${credentials.principal.type}'`
      );
    }
    return {
      token: exports.mockCredentials.limitedUser.token(
        credentials.principal.userEntityRef
      ),
      expiresAt: new Date(Date.now() + 36e5)
    };
  }
  listPublicServiceKeys() {
    throw new Error("Not implemented");
  }
}

var __accessCheck$3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$3 = (obj, member, getter) => {
  __accessCheck$3(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd$3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$3 = (obj, member, value, setter) => {
  __accessCheck$3(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var __privateMethod$2 = (obj, member, method) => {
  __accessCheck$3(obj, member, "access private method");
  return method;
};
var _auth, _defaultCredentials, _getCredentials, getCredentials_fn;
class MockHttpAuthService {
  constructor(pluginId, defaultCredentials) {
    __privateAdd$3(this, _getCredentials);
    __privateAdd$3(this, _auth, void 0);
    __privateAdd$3(this, _defaultCredentials, void 0);
    __privateSet$3(this, _auth, new MockAuthService({
      pluginId,
      disableDefaultAuthPolicy: false
    }));
    __privateSet$3(this, _defaultCredentials, defaultCredentials);
  }
  async credentials(req, options) {
    var _a;
    const credentials = await __privateMethod$2(this, _getCredentials, getCredentials_fn).call(this, req, (_a = options == null ? void 0 : options.allowLimitedAccess) != null ? _a : false);
    const allowedPrincipalTypes = options == null ? void 0 : options.allow;
    if (!allowedPrincipalTypes) {
      return credentials;
    }
    if (__privateGet$3(this, _auth).isPrincipal(credentials, "none")) {
      if (allowedPrincipalTypes.includes("none")) {
        return credentials;
      }
      throw new errors.AuthenticationError("Missing credentials");
    } else if (__privateGet$3(this, _auth).isPrincipal(credentials, "user")) {
      if (allowedPrincipalTypes.includes("user")) {
        return credentials;
      }
      throw new errors.NotAllowedError(
        `This endpoint does not allow 'user' credentials`
      );
    } else if (__privateGet$3(this, _auth).isPrincipal(credentials, "service")) {
      if (allowedPrincipalTypes.includes("service")) {
        return credentials;
      }
      throw new errors.NotAllowedError(
        `This endpoint does not allow 'service' credentials`
      );
    }
    throw new errors.NotAllowedError(
      "Unknown principal type, this should never happen"
    );
  }
  async issueUserCookie(res, options) {
    var _a;
    const credentials = (_a = options == null ? void 0 : options.credentials) != null ? _a : await this.credentials(res.req, { allow: ["user"] });
    res.setHeader(
      "Set-Cookie",
      exports.mockCredentials.limitedUser.cookie(credentials.principal.userEntityRef)
    );
    return { expiresAt: new Date(Date.now() + 36e5) };
  }
}
_auth = new WeakMap();
_defaultCredentials = new WeakMap();
_getCredentials = new WeakSet();
getCredentials_fn = async function(req, allowLimitedAccess) {
  var _a;
  const header = req.headers.authorization;
  const token = typeof header === "string" ? (_a = header.match(/^Bearer[ ]+(\S+)$/i)) == null ? void 0 : _a[1] : void 0;
  if (token) {
    if (token === MOCK_NONE_TOKEN) {
      return __privateGet$3(this, _auth).getNoneCredentials();
    }
    return await __privateGet$3(this, _auth).authenticate(token, {
      allowLimitedAccess
    });
  }
  if (allowLimitedAccess) {
    const cookieHeader = req.headers.cookie;
    if (cookieHeader) {
      const cookies = cookie.parse(cookieHeader);
      const cookie$1 = cookies[MOCK_AUTH_COOKIE];
      if (cookie$1) {
        return await __privateGet$3(this, _auth).authenticate(cookie$1, {
          allowLimitedAccess: true
        });
      }
    }
  }
  return __privateGet$3(this, _defaultCredentials);
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, key + "" , value);
  return value;
};
class MockUserInfoService {
  constructor(customInfo) {
    __publicField(this, "customInfo");
    this.customInfo = customInfo != null ? customInfo : {};
  }
  async getUserInfo(credentials) {
    const principal = credentials.principal;
    if (principal.type !== "user") {
      throw new errors.InputError(
        `User info not available for principal type '${principal.type}'`
      );
    }
    return {
      userEntityRef: principal.userEntityRef,
      ownershipEntityRefs: [principal.userEntityRef],
      ...this.customInfo
    };
  }
}

function simpleFactory(ref, factory) {
  return backendPluginApi.createServiceFactory((options) => ({
    service: ref,
    deps: {},
    async factory() {
      return factory(options);
    }
  }));
}
function simpleMock(ref, mockFactory) {
  return (partialImpl) => {
    const mock = mockFactory();
    if (partialImpl) {
      for (const [key, impl] of Object.entries(partialImpl)) {
        if (typeof impl === "function") {
          mock[key].mockImplementation(impl);
        } else {
          mock[key] = impl;
        }
      }
    }
    return Object.assign(mock, {
      factory: backendPluginApi.createServiceFactory({
        service: ref,
        deps: {},
        factory: () => mock
      })()
    });
  };
}
exports.mockServices = void 0;
((mockServices2) => {
  function rootConfig(options) {
    return new config.ConfigReader(options == null ? void 0 : options.data, "mock-config");
  }
  mockServices2.rootConfig = rootConfig;
  ((rootConfig2) => {
    rootConfig2.factory = simpleFactory(backendPluginApi.coreServices.rootConfig, rootConfig2);
  })(rootConfig = mockServices2.rootConfig || (mockServices2.rootConfig = {}));
  function rootLogger(options) {
    return MockRootLoggerService.create(options);
  }
  mockServices2.rootLogger = rootLogger;
  ((rootLogger2) => {
    rootLogger2.factory = simpleFactory(backendPluginApi.coreServices.rootLogger, rootLogger2);
    rootLogger2.mock = simpleMock(backendPluginApi.coreServices.rootLogger, () => ({
      child: jest.fn(),
      debug: jest.fn(),
      error: jest.fn(),
      info: jest.fn(),
      warn: jest.fn()
    }));
  })(rootLogger = mockServices2.rootLogger || (mockServices2.rootLogger = {}));
  function tokenManager() {
    return {
      async getToken() {
        return { token: "mock-token" };
      },
      async authenticate(token) {
        if (token !== "mock-token") {
          throw new Error("Invalid token");
        }
      }
    };
  }
  mockServices2.tokenManager = tokenManager;
  ((tokenManager2) => {
    tokenManager2.factory = simpleFactory(
      backendPluginApi.coreServices.tokenManager,
      tokenManager2
    );
    tokenManager2.mock = simpleMock(backendPluginApi.coreServices.tokenManager, () => ({
      authenticate: jest.fn(),
      getToken: jest.fn()
    }));
  })(tokenManager = mockServices2.tokenManager || (mockServices2.tokenManager = {}));
  function identity() {
    return new MockIdentityService();
  }
  mockServices2.identity = identity;
  ((identity2) => {
    identity2.factory = simpleFactory(backendPluginApi.coreServices.identity, identity2);
    identity2.mock = simpleMock(backendPluginApi.coreServices.identity, () => ({
      getIdentity: jest.fn()
    }));
  })(identity = mockServices2.identity || (mockServices2.identity = {}));
  function auth(options) {
    var _a;
    return new MockAuthService({
      pluginId: (_a = options == null ? void 0 : options.pluginId) != null ? _a : "test",
      disableDefaultAuthPolicy: Boolean(options == null ? void 0 : options.disableDefaultAuthPolicy)
    });
  }
  mockServices2.auth = auth;
  ((auth2) => {
    auth2.factory = backendPluginApi.createServiceFactory({
      service: backendPluginApi.coreServices.auth,
      deps: {
        plugin: backendPluginApi.coreServices.pluginMetadata,
        config: backendPluginApi.coreServices.rootConfig
      },
      factory({ plugin, config }) {
        const disableDefaultAuthPolicy = Boolean(
          config.getOptionalBoolean(
            "backend.auth.dangerouslyDisableDefaultAuthPolicy"
          )
        );
        return new MockAuthService({
          pluginId: plugin.getId(),
          disableDefaultAuthPolicy
        });
      }
    });
    auth2.mock = simpleMock(backendPluginApi.coreServices.auth, () => ({
      authenticate: jest.fn(),
      getNoneCredentials: jest.fn(),
      getOwnServiceCredentials: jest.fn(),
      isPrincipal: jest.fn(),
      getPluginRequestToken: jest.fn(),
      getLimitedUserToken: jest.fn(),
      listPublicServiceKeys: jest.fn()
    }));
  })(auth = mockServices2.auth || (mockServices2.auth = {}));
  function discovery() {
    return backendAppApi.HostDiscovery.fromConfig(
      new config.ConfigReader({
        backend: {
          // Invalid port to make sure that requests are always mocked
          baseUrl: "http://localhost:0",
          listen: { port: 0 }
        }
      })
    );
  }
  mockServices2.discovery = discovery;
  ((discovery2) => {
    discovery2.factory = backendAppApi.discoveryServiceFactory;
    discovery2.mock = simpleMock(backendPluginApi.coreServices.discovery, () => ({
      getBaseUrl: jest.fn(),
      getExternalBaseUrl: jest.fn()
    }));
  })(discovery = mockServices2.discovery || (mockServices2.discovery = {}));
  function httpAuth(options) {
    var _a, _b;
    return new MockHttpAuthService(
      (_a = options == null ? void 0 : options.pluginId) != null ? _a : "test",
      (_b = options == null ? void 0 : options.defaultCredentials) != null ? _b : exports.mockCredentials.user()
    );
  }
  mockServices2.httpAuth = httpAuth;
  ((httpAuth2) => {
    httpAuth2.factory = backendPluginApi.createServiceFactory(
      (options) => ({
        service: backendPluginApi.coreServices.httpAuth,
        deps: { plugin: backendPluginApi.coreServices.pluginMetadata },
        factory: ({ plugin }) => {
          var _a;
          return new MockHttpAuthService(
            plugin.getId(),
            (_a = options == null ? void 0 : options.defaultCredentials) != null ? _a : exports.mockCredentials.user()
          );
        }
      })
    );
    httpAuth2.mock = simpleMock(backendPluginApi.coreServices.httpAuth, () => ({
      credentials: jest.fn(),
      issueUserCookie: jest.fn()
    }));
  })(httpAuth = mockServices2.httpAuth || (mockServices2.httpAuth = {}));
  function userInfo(customInfo) {
    return new MockUserInfoService(customInfo);
  }
  mockServices2.userInfo = userInfo;
  ((userInfo2) => {
    userInfo2.factory = backendPluginApi.createServiceFactory({
      service: backendPluginApi.coreServices.userInfo,
      deps: {},
      factory() {
        return new MockUserInfoService();
      }
    });
    userInfo2.mock = simpleMock(backendPluginApi.coreServices.userInfo, () => ({
      getUserInfo: jest.fn()
    }));
  })(userInfo = mockServices2.userInfo || (mockServices2.userInfo = {}));
  ((cache2) => {
    cache2.factory = backendAppApi.cacheServiceFactory;
    cache2.mock = simpleMock(backendPluginApi.coreServices.cache, () => ({
      delete: jest.fn(),
      get: jest.fn(),
      set: jest.fn(),
      withOptions: jest.fn()
    }));
  })(mockServices2.cache || (mockServices2.cache = {}));
  ((database2) => {
    database2.factory = backendAppApi.databaseServiceFactory;
    database2.mock = simpleMock(backendPluginApi.coreServices.database, () => ({
      getClient: jest.fn()
    }));
  })(mockServices2.database || (mockServices2.database = {}));
  ((httpRouter2) => {
    httpRouter2.factory = backendAppApi.httpRouterServiceFactory;
    httpRouter2.mock = simpleMock(backendPluginApi.coreServices.httpRouter, () => ({
      use: jest.fn(),
      addAuthPolicy: jest.fn()
    }));
  })(mockServices2.httpRouter || (mockServices2.httpRouter = {}));
  ((rootHttpRouter2) => {
    rootHttpRouter2.factory = backendAppApi.rootHttpRouterServiceFactory;
    rootHttpRouter2.mock = simpleMock(backendPluginApi.coreServices.rootHttpRouter, () => ({
      use: jest.fn()
    }));
  })(mockServices2.rootHttpRouter || (mockServices2.rootHttpRouter = {}));
  ((lifecycle2) => {
    lifecycle2.factory = backendAppApi.lifecycleServiceFactory;
    lifecycle2.mock = simpleMock(backendPluginApi.coreServices.lifecycle, () => ({
      addShutdownHook: jest.fn(),
      addStartupHook: jest.fn()
    }));
  })(mockServices2.lifecycle || (mockServices2.lifecycle = {}));
  ((logger2) => {
    logger2.factory = backendAppApi.loggerServiceFactory;
    logger2.mock = simpleMock(backendPluginApi.coreServices.logger, () => ({
      child: jest.fn(),
      debug: jest.fn(),
      error: jest.fn(),
      info: jest.fn(),
      warn: jest.fn()
    }));
  })(mockServices2.logger || (mockServices2.logger = {}));
  ((permissions2) => {
    permissions2.factory = backendAppApi.permissionsServiceFactory;
    permissions2.mock = simpleMock(backendPluginApi.coreServices.permissions, () => ({
      authorize: jest.fn(),
      authorizeConditional: jest.fn()
    }));
  })(mockServices2.permissions || (mockServices2.permissions = {}));
  ((rootLifecycle2) => {
    rootLifecycle2.factory = backendAppApi.rootLifecycleServiceFactory;
    rootLifecycle2.mock = simpleMock(backendPluginApi.coreServices.rootLifecycle, () => ({
      addShutdownHook: jest.fn(),
      addStartupHook: jest.fn()
    }));
  })(mockServices2.rootLifecycle || (mockServices2.rootLifecycle = {}));
  ((scheduler2) => {
    scheduler2.factory = backendAppApi.schedulerServiceFactory;
    scheduler2.mock = simpleMock(backendPluginApi.coreServices.scheduler, () => ({
      createScheduledTaskRunner: jest.fn(),
      getScheduledTasks: jest.fn(),
      scheduleTask: jest.fn(),
      triggerTask: jest.fn()
    }));
  })(mockServices2.scheduler || (mockServices2.scheduler = {}));
  ((urlReader2) => {
    urlReader2.factory = backendAppApi.urlReaderServiceFactory;
    urlReader2.mock = simpleMock(backendPluginApi.coreServices.urlReader, () => ({
      readTree: jest.fn(),
      readUrl: jest.fn(),
      search: jest.fn()
    }));
  })(mockServices2.urlReader || (mockServices2.urlReader = {}));
  ((events2) => {
    events2.factory = pluginEventsNode.eventsServiceFactory;
    events2.mock = simpleMock(pluginEventsNode.eventsServiceRef, () => ({
      publish: jest.fn(),
      subscribe: jest.fn()
    }));
  })(mockServices2.events || (mockServices2.events = {}));
})(exports.mockServices || (exports.mockServices = {}));

const defaultServiceFactories = [
  exports.mockServices.auth.factory(),
  exports.mockServices.cache.factory(),
  exports.mockServices.rootConfig.factory(),
  exports.mockServices.database.factory(),
  exports.mockServices.httpAuth.factory(),
  exports.mockServices.httpRouter.factory(),
  exports.mockServices.identity.factory(),
  exports.mockServices.lifecycle.factory(),
  exports.mockServices.logger.factory(),
  exports.mockServices.permissions.factory(),
  exports.mockServices.rootLifecycle.factory(),
  exports.mockServices.rootLogger.factory(),
  exports.mockServices.scheduler.factory(),
  exports.mockServices.tokenManager.factory(),
  exports.mockServices.userInfo.factory(),
  exports.mockServices.urlReader.factory(),
  exports.mockServices.events.factory()
];
function createPluginsForOrphanModules(features) {
  const pluginIds = /* @__PURE__ */ new Set();
  const modulePluginIds = /* @__PURE__ */ new Set();
  for (const feature of features) {
    if (isInternalBackendFeature(feature)) {
      const registrations = feature.getRegistrations();
      for (const registration of registrations) {
        if (registration.type === "plugin") {
          pluginIds.add(registration.pluginId);
        } else if (registration.type === "module") {
          modulePluginIds.add(registration.pluginId);
        }
      }
    }
  }
  for (const pluginId of pluginIds) {
    modulePluginIds.delete(pluginId);
  }
  return Array.from(modulePluginIds).map(
    (pluginId) => backendPluginApi.createBackendPlugin({
      pluginId,
      register(reg) {
        reg.registerInit({ deps: {}, async init() {
        } });
      }
    })
  );
}
function createExtensionPointTestModules(features, extensionPointTuples) {
  if (!extensionPointTuples) {
    return [];
  }
  const registrations = features.flatMap((feature) => {
    if (feature.$$type !== "@backstage/BackendFeature") {
      throw new Error(
        `Failed to add feature, invalid type '${feature.$$type}'`
      );
    }
    if (isInternalBackendFeature(feature)) {
      if (feature.version !== "v1") {
        throw new Error(
          `Failed to add feature, invalid version '${feature.version}'`
        );
      }
      return feature.getRegistrations();
    }
    return [];
  });
  const extensionPointMap = new Map(
    extensionPointTuples.map((ep) => [ep[0].id, ep])
  );
  const extensionPointsToSort = new Set(extensionPointMap.keys());
  const extensionPointsByPlugin = /* @__PURE__ */ new Map();
  for (const registration of registrations) {
    if (registration.type === "module") {
      const testDep = Object.values(registration.init.deps).filter(
        (dep) => extensionPointsToSort.has(dep.id)
      );
      if (testDep.length > 0) {
        let points = extensionPointsByPlugin.get(registration.pluginId);
        if (!points) {
          points = [];
          extensionPointsByPlugin.set(registration.pluginId, points);
        }
        for (const { id } of testDep) {
          points.push(id);
          extensionPointsToSort.delete(id);
        }
      }
    }
  }
  if (extensionPointsToSort.size > 0) {
    const list = Array.from(extensionPointsToSort).map((id) => `'${id}'`).join(", ");
    throw new Error(
      `Unable to determine the plugin ID of extension point(s) ${list}. Tested extension points must be depended on by one or more tested modules.`
    );
  }
  const modules = [];
  for (const [pluginId, pluginExtensionPointIds] of extensionPointsByPlugin) {
    modules.push(
      backendPluginApi.createBackendModule({
        pluginId,
        moduleId: "test-extension-point-registration",
        register(reg) {
          for (const id of pluginExtensionPointIds) {
            const tuple = extensionPointMap.get(id);
            reg.registerExtensionPoint(...tuple);
          }
          reg.registerInit({ deps: {}, async init() {
          } });
        }
      })
    );
  }
  return modules;
}
function isPromise(value) {
  return typeof value === "object" && value !== null && "then" in value && typeof value.then === "function";
}
function unwrapFeature(feature) {
  return typeof feature === "function" ? feature() : feature;
}
const backendInstancesToCleanUp = new Array();
async function startTestBackend(options) {
  var _a, _b;
  const { extensionPoints, ...otherOptions } = options;
  const features = await Promise.all(
    (_b = (_a = options.features) == null ? void 0 : _a.map(async (val) => {
      if (isPromise(val)) {
        const { default: feature } = await val;
        return unwrapFeature(feature);
      }
      return unwrapFeature(val);
    })) != null ? _b : []
  );
  let server;
  const rootHttpRouterFactory = backendPluginApi.createServiceFactory({
    service: backendPluginApi.coreServices.rootHttpRouter,
    deps: {
      config: backendPluginApi.coreServices.rootConfig,
      lifecycle: backendPluginApi.coreServices.rootLifecycle,
      rootLogger: backendPluginApi.coreServices.rootLogger
    },
    async factory({ config, lifecycle, rootLogger }) {
      const router = backendAppApi.DefaultRootHttpRouter.create();
      const logger = rootLogger.child({ service: "rootHttpRouter" });
      const app = express__default.default();
      const middleware = backendAppApi.MiddlewareFactory.create({ config, logger });
      app.use(router.handler());
      app.use(middleware.notFound());
      app.use(middleware.error());
      server = await backendAppApi.createHttpServer(
        app,
        { listen: { host: "", port: 0 } },
        { logger }
      );
      lifecycle.addShutdownHook(() => server.stop(), { logger });
      await server.start();
      return router;
    }
  });
  const discoveryFactory = backendPluginApi.createServiceFactory({
    service: backendPluginApi.coreServices.discovery,
    deps: {
      rootHttpRouter: backendPluginApi.coreServices.rootHttpRouter
    },
    async factory() {
      if (!server) {
        throw new Error("Test server not started yet");
      }
      const port = server.port();
      const discovery = backendAppApi.HostDiscovery.fromConfig(
        new config.ConfigReader({
          backend: { baseUrl: `http://localhost:${port}`, listen: { port } }
        })
      );
      return discovery;
    }
  });
  const backend = backendAppApi.createSpecializedBackend({
    ...otherOptions,
    defaultServiceFactories: [
      ...defaultServiceFactories,
      rootHttpRouterFactory,
      discoveryFactory
    ]
  });
  backendInstancesToCleanUp.push(backend);
  for (const m of createExtensionPointTestModules(features, extensionPoints)) {
    backend.add(m);
  }
  for (const p of createPluginsForOrphanModules(features)) {
    backend.add(p);
  }
  for (const feature of features) {
    backend.add(feature);
  }
  await backend.start();
  return Object.assign(backend, {
    get server() {
      if (!server) {
        throw new Error("TestBackend server is not available");
      }
      return server;
    }
  });
}
let registered = false;
function registerTestHooks() {
  if (typeof afterAll !== "function") {
    return;
  }
  if (registered) {
    return;
  }
  registered = true;
  afterAll(async () => {
    await Promise.all(
      backendInstancesToCleanUp.map(async (backend) => {
        try {
          await backend.stop();
        } catch (error) {
          console.error(`Failed to stop backend after tests, ${error}`);
        }
      })
    );
    backendInstancesToCleanUp.length = 0;
  });
}
registerTestHooks();
function isInternalBackendFeature(feature) {
  return typeof feature.getRegistrations === "function";
}

var __accessCheck$2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$2 = (obj, member, getter) => {
  __accessCheck$2(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd$2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$2 = (obj, member, value, setter) => {
  __accessCheck$2(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$2(obj, member, "access private method");
  return method;
};
var _nodeIds, _cycleKeys, _getCycleKey, getCycleKey_fn, _nodes, _allProvided;
class Node {
  constructor(value, consumes, provides) {
    this.value = value;
    this.consumes = consumes;
    this.provides = provides;
  }
  static from(input) {
    return new Node(
      input.value,
      input.consumes ? new Set(input.consumes) : /* @__PURE__ */ new Set(),
      input.provides ? new Set(input.provides) : /* @__PURE__ */ new Set()
    );
  }
}
const _CycleKeySet = class _CycleKeySet {
  constructor(nodes) {
    __privateAdd$2(this, _getCycleKey);
    __privateAdd$2(this, _nodeIds, void 0);
    __privateAdd$2(this, _cycleKeys, void 0);
    __privateSet$2(this, _nodeIds, new Map(nodes.map((n, i) => [n.value, i])));
    __privateSet$2(this, _cycleKeys, /* @__PURE__ */ new Set());
  }
  static from(nodes) {
    return new _CycleKeySet(nodes);
  }
  tryAdd(path) {
    const cycleKey = __privateMethod$1(this, _getCycleKey, getCycleKey_fn).call(this, path);
    if (__privateGet$2(this, _cycleKeys).has(cycleKey)) {
      return false;
    }
    __privateGet$2(this, _cycleKeys).add(cycleKey);
    return true;
  }
};
_nodeIds = new WeakMap();
_cycleKeys = new WeakMap();
_getCycleKey = new WeakSet();
getCycleKey_fn = function(path) {
  return path.map((n) => __privateGet$2(this, _nodeIds).get(n)).sort().join(",");
};
let CycleKeySet = _CycleKeySet;
const _DependencyGraph = class _DependencyGraph {
  constructor(nodes) {
    __privateAdd$2(this, _nodes, void 0);
    __privateAdd$2(this, _allProvided, void 0);
    __privateSet$2(this, _nodes, nodes);
    __privateSet$2(this, _allProvided, /* @__PURE__ */ new Set());
    for (const node of __privateGet$2(this, _nodes).values()) {
      for (const produced of node.provides) {
        __privateGet$2(this, _allProvided).add(produced);
      }
    }
  }
  static fromMap(nodes) {
    return this.fromIterable(
      Object.entries(nodes).map(([key, node]) => ({
        value: String(key),
        ...node
      }))
    );
  }
  static fromIterable(nodeInputs) {
    const nodes = new Array();
    for (const nodeInput of nodeInputs) {
      nodes.push(Node.from(nodeInput));
    }
    return new _DependencyGraph(nodes);
  }
  /**
   * Find all nodes that consume dependencies that are not provided by any other node.
   */
  findUnsatisfiedDeps() {
    const unsatisfiedDependencies = [];
    for (const node of __privateGet$2(this, _nodes).values()) {
      const unsatisfied = Array.from(node.consumes).filter(
        (id) => !__privateGet$2(this, _allProvided).has(id)
      );
      if (unsatisfied.length > 0) {
        unsatisfiedDependencies.push({ value: node.value, unsatisfied });
      }
    }
    return unsatisfiedDependencies;
  }
  /**
   * Detect the first circular dependency within the graph, returning the path of nodes that
   * form a cycle, with the same node as the first and last element of the array.
   */
  detectCircularDependency() {
    return this.detectCircularDependencies().next().value;
  }
  /**
   * Detect circular dependencies within the graph, returning the path of nodes that
   * form a cycle, with the same node as the first and last element of the array.
   */
  *detectCircularDependencies() {
    const cycleKeys = CycleKeySet.from(__privateGet$2(this, _nodes));
    for (const startNode of __privateGet$2(this, _nodes)) {
      const visited = /* @__PURE__ */ new Set();
      const stack = new Array([
        startNode,
        [startNode.value]
      ]);
      while (stack.length > 0) {
        const [node, path] = stack.pop();
        if (visited.has(node)) {
          continue;
        }
        visited.add(node);
        for (const consumed of node.consumes) {
          const providerNodes = __privateGet$2(this, _nodes).filter(
            (other) => other.provides.has(consumed)
          );
          for (const provider of providerNodes) {
            if (provider === startNode) {
              if (cycleKeys.tryAdd(path)) {
                yield [...path, startNode.value];
              }
              break;
            }
            if (!visited.has(provider)) {
              stack.push([provider, [...path, provider.value]]);
            }
          }
        }
      }
    }
    return void 0;
  }
  /**
   * Traverses the dependency graph in topological order, calling the provided
   * function for each node and waiting for it to resolve.
   *
   * The nodes are traversed in parallel, but in such a way that no node is
   * visited before all of its dependencies.
   *
   * Dependencies of nodes that are not produced by any other nodes will be ignored.
   */
  async parallelTopologicalTraversal(fn) {
    const allProvided = __privateGet$2(this, _allProvided);
    const producedSoFar = /* @__PURE__ */ new Set();
    const waiting = new Set(__privateGet$2(this, _nodes).values());
    const visited = /* @__PURE__ */ new Set();
    const results = new Array();
    let inFlight = 0;
    async function processMoreNodes() {
      if (waiting.size === 0) {
        return;
      }
      const nodesToProcess = [];
      for (const node of waiting) {
        let ready = true;
        for (const consumed of node.consumes) {
          if (allProvided.has(consumed) && !producedSoFar.has(consumed)) {
            ready = false;
            continue;
          }
        }
        if (ready) {
          nodesToProcess.push(node);
        }
      }
      for (const node of nodesToProcess) {
        waiting.delete(node);
      }
      if (nodesToProcess.length === 0 && inFlight === 0) {
        throw new Error("Circular dependency detected");
      }
      await Promise.all(nodesToProcess.map(processNode));
    }
    async function processNode(node) {
      visited.add(node);
      inFlight += 1;
      const result = await fn(node.value);
      results.push(result);
      node.provides.forEach((produced) => producedSoFar.add(produced));
      inFlight -= 1;
      await processMoreNodes();
    }
    await processMoreNodes();
    return results;
  }
};
_nodes = new WeakMap();
_allProvided = new WeakMap();
let DependencyGraph = _DependencyGraph;

var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var _providedFactories, _loadedDefaultFactories, _implementations, _rootServiceImplementations, _addedFactoryIds, _instantiatedFactories, _resolveFactory, resolveFactory_fn, _checkForMissingDeps, checkForMissingDeps_fn;
function toInternalServiceFactory(factory) {
  const f = factory;
  if (f.$$type !== "@backstage/BackendFeature") {
    throw new Error(`Invalid service factory, bad type '${f.$$type}'`);
  }
  if (f.version !== "v1") {
    throw new Error(`Invalid service factory, bad version '${f.version}'`);
  }
  return f;
}
const pluginMetadataServiceFactory = backendPluginApi.createServiceFactory(
  (options) => ({
    service: backendPluginApi.coreServices.pluginMetadata,
    deps: {},
    factory: async () => ({ getId: () => options == null ? void 0 : options.pluginId })
  })
);
const _ServiceRegistry = class _ServiceRegistry {
  constructor(factories) {
    __privateAdd$1(this, _resolveFactory);
    __privateAdd$1(this, _checkForMissingDeps);
    __privateAdd$1(this, _providedFactories, void 0);
    __privateAdd$1(this, _loadedDefaultFactories, void 0);
    __privateAdd$1(this, _implementations, void 0);
    __privateAdd$1(this, _rootServiceImplementations, /* @__PURE__ */ new Map());
    __privateAdd$1(this, _addedFactoryIds, /* @__PURE__ */ new Set());
    __privateAdd$1(this, _instantiatedFactories, /* @__PURE__ */ new Set());
    __privateSet$1(this, _providedFactories, new Map(
      factories.map((sf) => [sf.service.id, toInternalServiceFactory(sf)])
    ));
    __privateSet$1(this, _loadedDefaultFactories, /* @__PURE__ */ new Map());
    __privateSet$1(this, _implementations, /* @__PURE__ */ new Map());
  }
  static create(factories) {
    const registry = new _ServiceRegistry(factories);
    registry.checkForCircularDeps();
    return registry;
  }
  checkForCircularDeps() {
    const graph = DependencyGraph.fromIterable(
      Array.from(__privateGet$1(this, _providedFactories)).map(
        ([serviceId, serviceFactory]) => ({
          value: serviceId,
          provides: [serviceId],
          consumes: Object.values(serviceFactory.deps).map((d) => d.id)
        })
      )
    );
    const circularDependencies = Array.from(graph.detectCircularDependencies());
    if (circularDependencies.length) {
      const cycles = circularDependencies.map((c) => c.map((id) => `'${id}'`).join(" -> ")).join("\n  ");
      throw new errors.ConflictError(`Circular dependencies detected:
  ${cycles}`);
    }
  }
  add(factory) {
    const factoryId = factory.service.id;
    if (factoryId === backendPluginApi.coreServices.pluginMetadata.id) {
      throw new Error(
        `The ${backendPluginApi.coreServices.pluginMetadata.id} service cannot be overridden`
      );
    }
    if (__privateGet$1(this, _addedFactoryIds).has(factoryId)) {
      throw new Error(
        `Duplicate service implementations provided for ${factoryId}`
      );
    }
    if (__privateGet$1(this, _instantiatedFactories).has(factoryId)) {
      throw new Error(
        `Unable to set service factory with id ${factoryId}, service has already been instantiated`
      );
    }
    __privateGet$1(this, _addedFactoryIds).add(factoryId);
    __privateGet$1(this, _providedFactories).set(factoryId, toInternalServiceFactory(factory));
  }
  async initializeEagerServicesWithScope(scope, pluginId = "root") {
    for (const factory of __privateGet$1(this, _providedFactories).values()) {
      if (factory.service.scope === scope) {
        if (scope === "root" && factory.initialization !== "lazy") {
          await this.get(factory.service, pluginId);
        } else if (scope === "plugin" && factory.initialization === "always") {
          await this.get(factory.service, pluginId);
        }
      }
    }
  }
  get(ref, pluginId) {
    var _a;
    __privateGet$1(this, _instantiatedFactories).add(ref.id);
    return (_a = __privateMethod(this, _resolveFactory, resolveFactory_fn).call(this, ref, pluginId)) == null ? void 0 : _a.then((factory) => {
      if (factory.service.scope === "root") {
        let existing = __privateGet$1(this, _rootServiceImplementations).get(factory);
        if (!existing) {
          __privateMethod(this, _checkForMissingDeps, checkForMissingDeps_fn).call(this, factory, pluginId);
          const rootDeps = new Array();
          for (const [name, serviceRef] of Object.entries(factory.deps)) {
            if (serviceRef.scope !== "root") {
              throw new Error(
                `Failed to instantiate 'root' scoped service '${ref.id}' because it depends on '${serviceRef.scope}' scoped service '${serviceRef.id}'.`
              );
            }
            const target = this.get(serviceRef, pluginId);
            rootDeps.push(target.then((impl) => [name, impl]));
          }
          existing = Promise.all(rootDeps).then(
            (entries) => factory.factory(Object.fromEntries(entries), void 0)
          );
          __privateGet$1(this, _rootServiceImplementations).set(factory, existing);
        }
        return existing;
      }
      let implementation = __privateGet$1(this, _implementations).get(factory);
      if (!implementation) {
        __privateMethod(this, _checkForMissingDeps, checkForMissingDeps_fn).call(this, factory, pluginId);
        const rootDeps = new Array();
        for (const [name, serviceRef] of Object.entries(factory.deps)) {
          if (serviceRef.scope === "root") {
            const target = this.get(serviceRef, pluginId);
            rootDeps.push(target.then((impl) => [name, impl]));
          }
        }
        implementation = {
          context: Promise.all(rootDeps).then(
            (entries) => {
              var _a2;
              return (_a2 = factory.createRootContext) == null ? void 0 : _a2.call(factory, Object.fromEntries(entries));
            }
          ).catch((error) => {
            const cause = errors.stringifyError(error);
            throw new Error(
              `Failed to instantiate service '${ref.id}' because createRootContext threw an error, ${cause}`
            );
          }),
          byPlugin: /* @__PURE__ */ new Map()
        };
        __privateGet$1(this, _implementations).set(factory, implementation);
      }
      let result = implementation.byPlugin.get(pluginId);
      if (!result) {
        const allDeps = new Array();
        for (const [name, serviceRef] of Object.entries(factory.deps)) {
          const target = this.get(serviceRef, pluginId);
          allDeps.push(target.then((impl) => [name, impl]));
        }
        result = implementation.context.then(
          (context) => Promise.all(allDeps).then(
            (entries) => factory.factory(Object.fromEntries(entries), context)
          )
        ).catch((error) => {
          const cause = errors.stringifyError(error);
          throw new Error(
            `Failed to instantiate service '${ref.id}' for '${pluginId}' because the factory function threw an error, ${cause}`
          );
        });
        implementation.byPlugin.set(pluginId, result);
      }
      return result;
    });
  }
};
_providedFactories = new WeakMap();
_loadedDefaultFactories = new WeakMap();
_implementations = new WeakMap();
_rootServiceImplementations = new WeakMap();
_addedFactoryIds = new WeakMap();
_instantiatedFactories = new WeakMap();
_resolveFactory = new WeakSet();
resolveFactory_fn = function(ref, pluginId) {
  if (ref.id === backendPluginApi.coreServices.pluginMetadata.id) {
    return Promise.resolve(
      toInternalServiceFactory(pluginMetadataServiceFactory({ pluginId }))
    );
  }
  let resolvedFactory = __privateGet$1(this, _providedFactories).get(ref.id);
  const { __defaultFactory: defaultFactory } = ref;
  if (!resolvedFactory && !defaultFactory) {
    return void 0;
  }
  if (!resolvedFactory) {
    let loadedFactory = __privateGet$1(this, _loadedDefaultFactories).get(defaultFactory);
    if (!loadedFactory) {
      loadedFactory = Promise.resolve().then(() => defaultFactory(ref)).then(
        (f) => toInternalServiceFactory(typeof f === "function" ? f() : f)
      );
      __privateGet$1(this, _loadedDefaultFactories).set(defaultFactory, loadedFactory);
    }
    resolvedFactory = loadedFactory.catch((error) => {
      throw new Error(
        `Failed to instantiate service '${ref.id}' because the default factory loader threw an error, ${errors.stringifyError(
          error
        )}`
      );
    });
  }
  return Promise.resolve(resolvedFactory);
};
_checkForMissingDeps = new WeakSet();
checkForMissingDeps_fn = function(factory, pluginId) {
  const missingDeps = Object.values(factory.deps).filter((ref) => {
    if (ref.id === backendPluginApi.coreServices.pluginMetadata.id) {
      return false;
    }
    if (__privateGet$1(this, _providedFactories).get(ref.id)) {
      return false;
    }
    return !ref.__defaultFactory;
  });
  if (missingDeps.length) {
    const missing = missingDeps.map((r) => `'${r.id}'`).join(", ");
    throw new Error(
      `Failed to instantiate service '${factory.service.id}' for '${pluginId}' because the following dependent services are missing: ${missing}`
    );
  }
};
let ServiceRegistry = _ServiceRegistry;

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  member.set(obj, value);
  return value;
};
var _subject, _registry;
const _ServiceFactoryTester = class _ServiceFactoryTester {
  constructor(subject, registry) {
    __privateAdd(this, _subject, void 0);
    __privateAdd(this, _registry, void 0);
    __privateSet(this, _subject, subject);
    __privateSet(this, _registry, registry);
  }
  /**
   * Creates a new {@link ServiceFactoryTester} used to test the provided subject.
   *
   * @param subject - The service factory to test.
   * @param options - Additional options
   * @returns A new tester instance for the provided subject.
   */
  static from(subject, options) {
    var _a, _b;
    const subjectFactory = typeof subject === "function" ? subject() : subject;
    const registry = ServiceRegistry.create([
      ...defaultServiceFactories,
      ...(_b = (_a = options == null ? void 0 : options.dependencies) == null ? void 0 : _a.map(
        (f) => typeof f === "function" ? f() : f
      )) != null ? _b : [],
      subjectFactory
    ]);
    return new _ServiceFactoryTester(subjectFactory.service, registry);
  }
  /**
   * Returns the service instance for the subject.
   *
   * @remarks
   *
   * If the subject is a plugin scoped service factory a plugin ID
   * can be provided to instantiate the service for a specific plugin.
   *
   * By default the plugin ID 'test' is used.
   */
  async get(...args) {
    const [pluginId] = args;
    return __privateGet(this, _registry).get(__privateGet(this, _subject), pluginId != null ? pluginId : "test");
  }
  /**
   * Return the service instance for any of the provided dependencies or built-in services.
   *
   * @remarks
   *
   * A plugin ID can optionally be provided for plugin scoped services, otherwise the plugin ID 'test' is used.
   */
  async getService(service, ...args) {
    const [pluginId] = args;
    const instance = await __privateGet(this, _registry).get(service, pluginId != null ? pluginId : "test");
    if (instance === void 0) {
      throw new Error(`Service '${service.id}' not found`);
    }
    return instance;
  }
};
_subject = new WeakMap();
_registry = new WeakMap();
let ServiceFactoryTester = _ServiceFactoryTester;

exports.ServiceFactoryTester = ServiceFactoryTester;
exports.TestDatabases = TestDatabases;
exports.createMockDirectory = createMockDirectory;
exports.isDockerDisabledForTests = isDockerDisabledForTests;
exports.setupRequestMockHandlers = setupRequestMockHandlers;
exports.startTestBackend = startTestBackend;
//# sourceMappingURL=index.cjs.js.map
